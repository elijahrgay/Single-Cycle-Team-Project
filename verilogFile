// Testbench options
`define	TRACE	1	// enable simulation trace
`define RUNTIME 500	// How long simulator can run
`define CLKDEL  2	// CLocK transition delay

// Types
`define WORD	[31:0]	// size of a data word
`define ADDR	[31:0]	// size of a memory address
`define INST	[31:0]	// size of an instruction
`define REG	[4:0]	// size of a register number
`define	REGCNT	[31:0]	// register count
`define	MEMCNT	[511:0] // memory count implemented
`define	OPCODE	[5:0]	// 6-bit opcodes
`define	EXTOP	[6:0]	// {!RTYPE, OPCODE}

// Fields
`define OP	[31:26]	// opcode field
`define RS	[25:21]	// rs field
`define RT	[20:16]	// rt field
`define RD	[15:11]	// rd field
`define IMM	[15:0]	// immediate/offset field
`define SHAMT	[10:6]	// shift ammount
`define FUNCT	[5:0]	// function code (opcode extension)
`define JADDR	[25:0]	// jump address field
`define	JPACK(R,O,J)		begin R`OP=O; R`JADDR=((J)>>2); end
`define	IPACK(R,O,S,T,I)	begin R`OP=O; R`RS=S; R`RT=T; R`IMM=I; end
`define	RPACK(R,S,T,D,SH,FU)	begin R`OP=`RTYPE; R`RS=S; R`RT=T; R`RD=D; R`SHAMT=SH; R`FUNCT=FU; end

// Instruction encoding
`define	RTYPE	6'h00	// OP field for all RTYPE instructions
`define BEQ	6'h04	// OP field
`define BNE	6'h06	// OP field -- to be implemented!
`define	ADDIU	6'h09	// OP field
`define	SLTIU	6'h0b	// OP field
`define	ANDI	6'h0c	// OP field
`define	ORI	6'h0d	// OP field
`define	XORI	6'h0e	// OP field
`define	LUI	6'h0f	// OP field
`define	LW	6'h23	// OP field
`define	SW	6'h2b	// OP field
`define	SLLV	6'h04	// FUNCT field -- to be implemented!
`define	SRLV	6'h06	// FUNCT field -- to be implemented!
`define	SRAV	6'h07	// FUNCT field -- to be implemented!
`define	ADDU	6'h21	// FUNCT field
`define	SUBU	6'h23	// FUNCT field
`define	AND	6'h24	// FUNCT field
`define	OR	6'h25	// FUNCT field
`define	XOR	6'h26	// FUNCT field
`define	NOR	6'h27	// FUNCT field -- to be implemented!
`define	SLTU	6'h2b	// FUNCT field
`define	F(A)	{1'b1, A} // in FUNCT field
`define	TRAP	7'h7f	// illegal operation

// Decode OP, FUNCT into one 7-bit EXTOP
module decode(xop, ir);
output reg `EXTOP xop;	// decoded 7-bit op
input `INST ir;		// instruction

always @(ir) begin
  case (ir `OP)
    `RTYPE:	case (ir `FUNCT)
		  `ADDU, `SUBU, `NOR, `SLLV, `SRLV, `SRAV,
		  `AND, `OR, `XOR,
		  `SLTU:	xop = `F(ir `FUNCT);
		  default:	xop = `TRAP;
		endcase
    `BEQ, `BNE,
    `ADDIU, `SLTIU,
    `ANDI, `ORI, `XORI,
    `LUI, `LW, `SW:	xop = ir `OP;
    default:		xop = `TRAP;
  endcase
end
endmodule

// General-purpose ALU
module alu(zero, res, xop, top, bot);
output zero;		// res is 0?
output reg `WORD res;	// combinatorial result
input `EXTOP xop;	// extended operation
input `WORD top, bot;	// top & bottom inputs

assign zero = (res == 0);

// combinatorial always using sensitivity list
// output declared as reg, but never use <=
always @(xop or top or bot) begin
  case (xop)
    `LW, `SW,
    `ADDIU, `F(`ADDU):	res = (top + bot);
    `F(`SLLV): res = top << bot[4:0];
    `F(`SRLV): res = top >> bot[4:0];
    `F(`SRAV): res = {{32{top[31]}}, top} >> bot[4:0];
    `F(`NOR): res = ~(top | bot);
    `SLTIU, `F(`SLTU):	res = (top < bot);
    `ANDI, `F(`AND):	res = (top & bot);
    `ORI, `F(`OR):	res = (top | bot);
    `XORI, `F(`XOR):	res = (top ^ bot);
    `LUI:		res = (bot << 16);
    `BEQ, `BNE, `F(`SUBU):	res = (top - bot);

    // should always cover all possible values
    default:	res = top;
  endcase
end
endmodule

// Generic multi-cycle processor
module processor(halt, reset, clk);
output reg halt;
input reset, clk;
reg `ADDR pc;
reg `WORD m `MEMCNT;
reg `WORD r `REGCNT;
wire `INST ir;

// Initialize register file and memory
initial begin
    r[1] = 22; r[2] = 1; r[3] = 42;
    r[4] = 601;	r[5] = 11811;
    
    r[6] = 32'hAAAAAAAA;
    r[7] = 32'h55555555;

    r[9] = 32'h87654321; 
    r[10] = 32'h00000004; 

    r[14] = 100;
    r[15] = 100;

    `RPACK(m[0], 2, 3, 1, 0, `ADDU)
    `RPACK(m[1], 2, 3, 1, 0, `SLTU)
    `RPACK(m[2], 3, 5, 1, 0, `AND)
    `RPACK(m[3], 5, 3, 1, 0, `OR)
    `RPACK(m[4], 3, 5, 1, 0, `XOR)
    `RPACK(m[5], 4, 3, 1, 0, `SUBU)
    `IPACK(m[6], `ADDIU, 3, 1, -1)
    `IPACK(m[7], `SLTIU, 5, 1, 12345)
    `IPACK(m[8], `ANDI, 3, 1, 3)
    `IPACK(m[9], `ORI, 3, 1, 3)
    `IPACK(m[10], `XORI, 3, 1, 3)
    `IPACK(m[11], `LUI, 0, 1, 1)
    `IPACK(m[12], `LW, 2, 1, 1023)
    `IPACK(m[13], `SW, 0, 2, 1024)
    `IPACK(m[14], `BEQ, 4, 5, -1)

    `RPACK(m[15], 6, 7, 8, 0, `NOR) //r6 = 32'hAAAAAAAA ~| r7 = 32'h55555555 Therefore r8 = 0
    `RPACK(m[16], 9, 10, 11, 0, `SLLV) //r11 = 32'h76543210
    `RPACK(m[17], 9, 10, 12, 0, `SRLV) //r12 = 32'h08765432
    `RPACK(m[18], 9, 10, 13, 0, `SRAV) //r13 = 32'hF8765432
    `IPACK(m[19], `BNE, 4, 5, 2)       // Skip because not equal
    `RPACK(m[20], 0, 0, 1, 0, `ADDU) // skipped
    `RPACK(m[21], 0, 0, 1, 0, `ADDU) // skipped
    `IPACK(m[22], `BNE, 14, 15, 1)   //No skip
    `IPACK(m[22], `ADDIU, 1, 1, 1) // runs
    
    m[24] = 0;
    m[256] = 22;
end

assign ir = m[pc >> 2];

// Control output signals
wire Branch, RegDst, MemRead, MemtoReg;
wire `OPCODE ALUop;
wire ALUSrc, MemWrite, RegWrite;

// Mux outputs
wire `REG RegDstMux;
wire `WORD ALUSrcMux, BranchZeroMux, MemtoRegMux;

// Function unit wiring
wire `WORD Signextend, Shiftleft2;
wire `ADDR PCAdd, BranchAdd;
wire `EXTOP ALUcontrol;
wire Zero;
wire `WORD ALUresult;

// Control logic
assign RegDst = (ir `OP == `RTYPE);
assign ALUSrc = ((ir `OP != `RTYPE) && (ir `OP != `BEQ) && (ir `OP != `BNE));
assign ALUOp = (ir `OP);
assign MemRead = (ir `OP == `LW);
assign MemtoReg = (ir `OP == `LW);
assign MemWrite = (ir `OP == `SW);
assign RegWrite = ((ir `OP != `SW) && (ir `OP != `BEQ) && (ir `OP != `BNE));
assign RegDstMux = (RegDst ? ir `RD : ir `RT);
assign ALUSrcMux = (ALUSrc ? Signextend : r[ir `RT]);
assign MemtoRegMux = (MemtoReg ? m[ALUresult >> 2] : ALUresult);
assign Branch = (ir `OP == `BEQ && Zero) || (ir `OP == `BNE && !Zero);
assign BranchZeroMux = ((Branch) ? BranchAdd : PCAdd);

// Function units
assign Signextend = {{16{ir[15]}}, ir `IMM};
assign Shiftleft2 = {Signextend[29:0], 2'b00};
assign PCAdd = (pc + 4);
assign BranchAdd = (PCAdd + Shiftleft2);
decode DECODE(ALUcontrol, ir);
alu    ALU(Zero, ALUresult, ALUcontrol, r[ir `RS], ALUSrcMux);

always @(posedge clk) begin
  if (reset) begin
    // reset
    pc <= 0;
    halt <= 0;
    r[0] <= 0;
  end else begin
    // normal operation
    if (!halt) begin
      if (ALUcontrol != `TRAP) begin
`ifdef	TRACE
        if (ir `OP == 2) $display("%d: OP=%x JADDR=%d", pc, ir `OP, ir `JADDR);
        else if (ir `OP) $display("%d: OP=%x RS=%d RT=%d IMM=%x", pc, ir `OP, ir `RS, ir `RT, ir `IMM);
        else $display("%d: OP=%x RS=%d RT=%d RD=%d SHAMT=%d FUNCT=%x", pc, ir `OP, ir `RS, ir `RT, ir `RD, ir `SHAMT, ir `FUNCT);
        if (MemWrite) $display("%d: m[%d] <= r[%d] (%d)", pc, ALUresult, ir `RT, r[ir `RT]);
        if (RegWrite) $display("%d: r[%d] <= %d", pc, RegDstMux, MemtoRegMux);
        $display("%d: pc <= %d", pc, BranchZeroMux);
`endif
        if (MemWrite) m[ALUresult >> 2] <= r[ir `RT];
        if (RegWrite) r[RegDstMux] <= MemtoRegMux;
        pc <= BranchZeroMux;
      end else halt <= 1;
    end
  end
end
endmodule

// Testbench
module bench;
wire halt;
reg reset = 1;
reg clk = 0;

processor PE(halt, reset, clk);

initial begin
  #`CLKDEL clk = 1;
  #`CLKDEL clk = 0;
  reset = 0;
  while (($time < `RUNTIME) && !halt) begin
    #`CLKDEL clk = 1;
    #`CLKDEL clk = 0;
  end
end
endmodule
